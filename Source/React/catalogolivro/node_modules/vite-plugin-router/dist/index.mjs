var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/index.ts
import path3 from "path";
import chokidar from "chokidar";
import lodash from "lodash";

// src/constants.ts
var extensions = [".tsx", ".ts", ".jsx", ".js"];
var DEFAULT_DIR = "src/app";
var DEFAULT_OUT_DIR = "src";
var CURRENT_DIR = process.cwd();
var ROOT_DIR = "/";

// src/generateRoutes.ts
import path2 from "path";
import fs2 from "fs";

// src/utils/findLayout.ts
function findLayoutForFile(files, layouts) {
  const pathSegments = files.path.split(ROOT_DIR).filter((segment) => segment !== "");
  for (let i = pathSegments.length; i >= 0; i--) {
    const currentPath = `${ROOT_DIR}${pathSegments.slice(0, i).join(ROOT_DIR)}`;
    const matchingLayout = layouts.find((layout) => layout.path === currentPath);
    if (matchingLayout) {
      return matchingLayout.path;
    }
  }
  return null;
}
function findLayout(files, layouts) {
  return files.map((file) => {
    const layout = findLayoutForFile(file, layouts);
    return __spreadProps(__spreadValues({}, file), {
      layout
    });
  });
}

// src/utils/getFilesWithExtensions.ts
import fs from "fs";
import path from "path";
function getFilesWithExtensions(dir) {
  const files = [];
  function traverseDirectory(dir2, currentPath = "") {
    const items = fs.readdirSync(dir2);
    items.forEach((item) => {
      const itemPath = path.join(dir2, item);
      const isDirectory = fs.statSync(itemPath).isDirectory();
      if (isDirectory) {
        const newPath = path.join(currentPath, item).replace(/\\/g, ROOT_DIR);
        traverseDirectory(itemPath, newPath);
        return;
      }
      const fileExtension = path.extname(item);
      if (extensions.includes(fileExtension)) {
        const filePath = currentPath === "" ? ROOT_DIR : `${ROOT_DIR}${currentPath}`;
        files.push({ path: filePath, name: item });
      }
    });
    return files;
  }
  traverseDirectory(dir);
  return files;
}

// src/utils/index.ts
function formatPath(path4) {
  return path4.replace(/\[(.+?)\]/g, ":$1");
}
function formatFileName(fileName) {
  fileName = fileName.replace(/\.(tsx?|jsx?|ts|js)$/i, "");
  if (fileName.toLowerCase() === "index") {
    return "";
  }
  if (fileName.match(/^\[(.+?)\]$/)) {
    fileName = `:${fileName.slice(1, -1)}`;
  }
  return `${ROOT_DIR}${fileName}`;
}

// src/utils/processFiles.ts
function processFiles(files) {
  const processedFiles = [];
  const layoutFiles = [];
  files.forEach(({ name, path: path4 }) => {
    if (name.includes("style") || name.includes("css"))
      return;
    if (name.includes("layout")) {
      layoutFiles.push({ name, path: path4 });
      return;
    }
    const processedPath = formatPath(path4);
    const fileName = formatFileName(name);
    if (processedPath === ROOT_DIR) {
      processedFiles.push({
        path: path4,
        name,
        route: fileName
      });
      return;
    }
    processedFiles.push({
      path: path4,
      name,
      route: `${processedPath}${fileName}`
    });
  });
  return {
    files: processedFiles,
    layouts: layoutFiles
  };
}

// src/template/utils.ts
function getCustomLayoutName(path4) {
  if (!path4)
    return null;
  let name = path4.replace(/\//g, "");
  name = name.replace(/\[(.*?)\]/g, (match) => {
    const paramName = match.substring(1, match.length - 1);
    return paramName.charAt(0).toUpperCase() + paramName.slice(1);
  });
  name = name.charAt(0).toUpperCase() + name.slice(1);
  name = name.replace(/[^\w\s]/gi, "");
  name = name.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  if (name === "") {
    name = "Root";
  }
  return `${name}Layout`;
}
function formatPathFromFilename(filename) {
  const extensionRemoved = filename.replace(/\.(tsx?|jsx?|ts|js)$/i, "");
  if (extensionRemoved === "index") {
    return "";
  } else {
    return `/${extensionRemoved}`;
  }
}
function getImporPath(path4, file) {
  if (path4 === "/" && file.includes("index")) {
    return "./app/index";
  }
  return `./app${path4 !== "/" ? path4 : ""}${formatPathFromFilename(file)}`;
}
function generateImports(routes) {
  return routes.map(({ path: path4, name }, index) => {
    const fileName = `File${index + 1}`;
    const filePath = getImporPath(path4, name);
    return `const ${fileName} = lazy(() => import('${filePath}'));`;
  }).join("\n");
}
function generateLayoutImports(layouts) {
  return layouts.map(({ path: path4, name }) => {
    const fileName = getCustomLayoutName(path4);
    const filePath = `./app${path4 !== "/" ? path4 : ""}${formatPathFromFilename(name)}`;
    return `const ${fileName} = lazy(() => import('${filePath}'));`;
  }).join("\n");
}
function generateRoutes(routes) {
  return routes.map(({ route, layout }, index) => {
    const fileName = `File${index + 1}`;
    const layoutName = getCustomLayoutName(layout);
    const processedLayout = layoutName === null ? `<${fileName} />` : `
              <${layoutName}>
                <${fileName} />
              </${layoutName}>
            `;
    return `
          <Route 
            element={${processedLayout}} 
            path="${route === "" ? "/" : route}" 
            key="${route === "" ? "/" : route}"  
          />`;
  }).join("\n        ");
}

// src/template/index.ts
function template(routes, layouts) {
  return `// Created by Vite Router https://www.npmjs.com/package/vite-plugin-router
  // @ts-nocheck
  // prettier-ignore
import React, { lazy, Suspense } from 'react';
import { BrowserRouter, Route, Routes } from 'react-router-dom';

${generateImports(routes)}

${generateLayoutImports(layouts)}

function Error404() {
  return <div>404</div>;
}

function Loading() {
  return <div>Loading...</div>;
}

interface IAppRoutesProps {
  custom404?: React.ReactNode;
  customLoading?: React.ReactNode;
}

export function AppRoutes({ custom404: Custom404, customLoading: CustomLoading }: IAppRoutesProps) {
  return (
    <BrowserRouter>
      <Suspense fallback={CustomLoading || <Loading />}>
        <Routes>
          ${generateRoutes(routes)}
          <Route
            path="*"
            element={Custom404 || <Error404 />}
          />
        </Routes>
      </Suspense> 
    </BrowserRouter>
  );
}
`;
}

// src/utils/log/index.ts
import pino from "pino";
var Log = pino({
  level: "info",
  transport: {
    target: "pino-pretty",
    options: {
      colorize: true,
      translateTime: "SYS:HH:MM:ss.l",
      levelFirst: true,
      ignore: "pid,hostname,time"
    }
  }
}).child({ name: "VITE ROUTER" });

// src/generateRoutes.ts
function generateRoutes2({ dir = "", outDir = "" }) {
  const getFiles = getFilesWithExtensions(dir);
  const { files, layouts } = processFiles(getFiles);
  const routes = findLayout(files, layouts);
  const generateTemplate = template(routes, layouts);
  const fileName = "routes.tsx";
  const filePath = path2.join(CURRENT_DIR, outDir, fileName);
  fs2.writeFileSync(filePath, generateTemplate, "utf-8");
  Log.info(`Generated successfully`);
}

// src/index.ts
function viteRouter({
  dir = DEFAULT_DIR,
  outDir = DEFAULT_OUT_DIR
} = {}) {
  const dirPath = path3.resolve(CURRENT_DIR, dir);
  const chokidarWatcher = chokidar.watch(dirPath);
  const debounceGenerateRoutes = lodash.debounce(generateRoutes2, 100);
  return {
    name: "vite-plugin-router",
    configureServer() {
      chokidarWatcher.on("add", () => {
        debounceGenerateRoutes({ dir: dirPath, outDir });
      });
      chokidarWatcher.on("unlink", () => {
        debounceGenerateRoutes({ dir: dirPath, outDir });
      });
      chokidarWatcher.on("ready", () => {
        Log.info("Vite router is ready");
        Log.info(`Observing in: ${dirPath}`);
      });
    },
    closeBundle() {
      chokidarWatcher.close();
    }
  };
}
export {
  viteRouter as default
};
//# sourceMappingURL=index.mjs.map